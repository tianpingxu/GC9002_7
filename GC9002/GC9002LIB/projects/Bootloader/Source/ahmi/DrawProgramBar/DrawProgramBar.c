#include "gc90x_cache.h"
#include "gc90x_display.h"
#include "gc90x_ahmi.h"
#include "DrawProgramBar.h"
#include "string.h"
#include "em_ct.h"
#include "upgrade_c1.h"


const unsigned char ASCII_8X16_array[]={
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x1E,0x3F,0x3F,0x3F,0x3F,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x7F,0x7F,0x61,0x41,0x41,0x41,0x41,0x61,0x7F,0x7F,0x7F,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0x03,0x02,0x02,0x04,0x38,0x44,0x44,0x44,0x44,0x38,0x00,0x00,0x00,
0x1C,0x22,0x22,0x22,0x22,0x1C,0x08,0x08,0x7F,0x08,0x08,0x08,0x08,0x08,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x01,0x0F,0x1C,0x13,0x1F,0x18,0x10,0x10,0x10,0x11,0x13,0x72,0x60,0x00,0x00,
0x08,0x08,0x49,0x3E,0x36,0x22,0x22,0x63,0x22,0x22,0x36,0x3E,0x49,0x08,0x08,0x00,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x7F,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,
0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0x3F,0x0F,0x07,0x03,0x01,0x00,0x00,0x00,
0x08,0x1C,0x2C,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x1C,0x08,0x00,0x00,
0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x00,0x14,0x14,0x00,0x00,0x00,0x00,
0x1F,0x25,0x45,0x45,0x45,0x25,0x1D,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x00,0x00,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x78,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,
0x08,0x18,0x1C,0x2A,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,
0x00,0x00,0x00,0x00,0x00,0x04,0x02,0x7F,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x10,0x20,0x7F,0x20,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x0C,0x0C,0x00,0x00,0x00,
0x0A,0x14,0x14,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x0A,0x0A,0x0A,0x3F,0x0A,0x1E,0x14,0x3F,0x14,0x14,0x14,0x00,0x00,0x00,
0x00,0x08,0x1C,0x2A,0x2A,0x28,0x18,0x0C,0x0A,0x0A,0x2A,0x2A,0x1C,0x08,0x08,0x00,
0x00,0x00,0x22,0x52,0x54,0x54,0x58,0x2A,0x0D,0x15,0x15,0x25,0x22,0x00,0x00,0x00,
0x00,0x00,0x10,0x28,0x28,0x28,0x30,0x5E,0x54,0x54,0x4C,0x44,0x3B,0x00,0x00,0x00,
0x30,0x30,0x10,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x02,0x04,0x04,0x08,0x08,0x08,0x08,0x08,0x08,0x04,0x04,0x02,0x01,0x00,0x00,
0x20,0x10,0x08,0x08,0x04,0x04,0x04,0x04,0x04,0x04,0x08,0x08,0x10,0x20,0x00,0x00,
0x00,0x00,0x00,0x08,0x08,0x6B,0x1C,0x1C,0x6B,0x08,0x08,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x7F,0x08,0x08,0x08,0x08,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x10,0x60,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,
0x00,0x01,0x02,0x02,0x02,0x04,0x04,0x08,0x08,0x08,0x10,0x10,0x20,0x20,0x00,0x00,
0x00,0x00,0x0C,0x12,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x12,0x0C,0x00,0x00,0x00,
0x00,0x00,0x08,0x38,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,0x00,
0x00,0x00,0x1E,0x21,0x21,0x21,0x02,0x02,0x04,0x08,0x10,0x21,0x3F,0x00,0x00,0x00,
0x00,0x00,0x1E,0x21,0x21,0x02,0x0C,0x02,0x01,0x01,0x21,0x22,0x1E,0x00,0x00,0x00,
0x00,0x00,0x04,0x04,0x0C,0x14,0x14,0x24,0x24,0x3F,0x04,0x04,0x0F,0x00,0x00,0x00,
0x00,0x00,0x3F,0x20,0x20,0x20,0x2E,0x31,0x01,0x01,0x21,0x21,0x1E,0x00,0x00,0x00,
0x00,0x00,0x0E,0x12,0x20,0x20,0x2E,0x33,0x21,0x21,0x21,0x13,0x0E,0x00,0x00,0x00,
0x00,0x00,0x3F,0x22,0x22,0x04,0x04,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x00,
0x00,0x00,0x1E,0x33,0x21,0x21,0x12,0x1E,0x21,0x21,0x21,0x23,0x1E,0x00,0x00,0x00,
0x00,0x00,0x1C,0x22,0x21,0x21,0x21,0x23,0x1D,0x01,0x02,0x12,0x1C,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x0C,0x0C,0x00,0x00,0x00,0x00,0x0C,0x0C,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x10,0x00,
0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x10,0x08,0x04,0x02,0x01,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x02,0x04,0x08,0x10,0x20,0x00,0x00,0x00,
0x00,0x00,0x1E,0x21,0x21,0x21,0x01,0x02,0x04,0x04,0x00,0x0C,0x0C,0x00,0x00,0x00,
0x00,0x00,0x1C,0x22,0x2D,0x55,0x55,0x55,0x55,0x5A,0x21,0x22,0x1C,0x00,0x00,0x00,
0x00,0x00,0x08,0x08,0x14,0x14,0x14,0x14,0x3C,0x22,0x22,0x22,0x77,0x00,0x00,0x00,
0x00,0x00,0x7E,0x21,0x21,0x22,0x3C,0x22,0x21,0x21,0x21,0x21,0x7E,0x00,0x00,0x00,
0x00,0x00,0x1F,0x21,0x41,0x40,0x40,0x40,0x40,0x40,0x61,0x22,0x1C,0x00,0x00,0x00,
0x00,0x00,0x7C,0x22,0x23,0x21,0x21,0x21,0x21,0x21,0x23,0x22,0x7C,0x00,0x00,0x00,
0x00,0x00,0x7E,0x21,0x24,0x24,0x3C,0x24,0x24,0x20,0x21,0x21,0x7E,0x00,0x00,0x00,
0x00,0x00,0x7E,0x21,0x24,0x24,0x3C,0x24,0x24,0x20,0x20,0x20,0x70,0x00,0x00,0x00,
0x00,0x00,0x1E,0x22,0x22,0x40,0x40,0x40,0x47,0x42,0x22,0x22,0x1C,0x00,0x00,0x00,
0x00,0x00,0x77,0x22,0x22,0x22,0x22,0x3E,0x22,0x22,0x22,0x22,0x77,0x00,0x00,0x00,
0x00,0x00,0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,0x00,
0x00,0x00,0x1F,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x44,0x78,0x00,
0x00,0x00,0x77,0x22,0x24,0x28,0x38,0x28,0x24,0x24,0x22,0x22,0x77,0x00,0x00,0x00,
0x00,0x00,0x70,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x21,0x7F,0x00,0x00,0x00,
0x00,0x00,0x77,0x36,0x36,0x36,0x36,0x2A,0x2A,0x2A,0x2A,0x2A,0x6B,0x00,0x00,0x00,
0x00,0x00,0x77,0x32,0x32,0x2A,0x2A,0x2A,0x2A,0x26,0x26,0x26,0x72,0x00,0x00,0x00,
0x00,0x00,0x1C,0x22,0x42,0x41,0x41,0x41,0x41,0x41,0x41,0x22,0x1C,0x00,0x00,0x00,
0x00,0x00,0x7E,0x23,0x21,0x21,0x23,0x3E,0x20,0x20,0x20,0x20,0x70,0x00,0x00,0x00,
0x00,0x00,0x1C,0x22,0x41,0x41,0x41,0x41,0x41,0x59,0x66,0x26,0x1C,0x03,0x00,0x00,
0x00,0x00,0x7C,0x22,0x22,0x22,0x3C,0x28,0x24,0x24,0x22,0x22,0x73,0x00,0x00,0x00,
0x00,0x00,0x1F,0x31,0x21,0x20,0x10,0x0C,0x03,0x01,0x21,0x23,0x3E,0x00,0x00,0x00,
0x00,0x00,0x7F,0x49,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x1C,0x00,0x00,0x00,
0x00,0x00,0x77,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x1C,0x00,0x00,0x00,
0x00,0x00,0x77,0x22,0x22,0x22,0x14,0x14,0x14,0x14,0x1C,0x08,0x08,0x00,0x00,0x00,
0x00,0x10,0x6B,0x2A,0x2A,0x3A,0x3A,0x36,0x36,0x14,0x14,0x14,0x14,0x00,0x00,0x00,
0x00,0x00,0x77,0x22,0x34,0x14,0x1C,0x08,0x0C,0x14,0x16,0x22,0x77,0x00,0x00,0x00,
0x00,0x00,0x77,0x22,0x22,0x14,0x14,0x08,0x08,0x08,0x08,0x08,0x1C,0x00,0x00,0x00,
0x00,0x00,0x1F,0x22,0x02,0x04,0x04,0x0C,0x08,0x08,0x10,0x11,0x3E,0x00,0x00,0x00,
0x0F,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0x00,0x00,
0x00,0x20,0x20,0x10,0x10,0x10,0x08,0x08,0x08,0x04,0x04,0x02,0x02,0x02,0x01,0x00,
0x3C,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x3C,0x00,0x00,
0x0C,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,
0x30,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x22,0x0E,0x32,0x22,0x22,0x1F,0x00,0x00,0x00,
0x00,0x00,0x60,0x20,0x20,0x20,0x2E,0x33,0x21,0x21,0x21,0x33,0x2E,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x0E,0x00,0x00,0x00,
0x00,0x00,0x03,0x01,0x01,0x01,0x1F,0x21,0x21,0x21,0x21,0x23,0x1D,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x21,0x3F,0x20,0x20,0x21,0x1E,0x00,0x00,0x00,
0x00,0x00,0x07,0x09,0x08,0x08,0x3E,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x22,0x22,0x1C,0x20,0x1E,0x21,0x21,0x1E,0x00,
0x00,0x00,0x60,0x20,0x20,0x20,0x2E,0x31,0x21,0x21,0x21,0x21,0x73,0x00,0x00,0x00,
0x00,0x00,0x18,0x18,0x00,0x00,0x38,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,0x00,
0x00,0x00,0x06,0x06,0x00,0x00,0x0E,0x02,0x02,0x02,0x02,0x02,0x02,0x22,0x3C,0x00,
0x00,0x00,0x60,0x20,0x20,0x20,0x27,0x24,0x28,0x34,0x24,0x22,0x77,0x00,0x00,0x00,
0x00,0x00,0x38,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x2A,0x2A,0x2A,0x2A,0x2A,0x6B,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x6E,0x31,0x21,0x21,0x21,0x21,0x73,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x12,0x21,0x21,0x21,0x13,0x1E,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x6E,0x31,0x21,0x21,0x21,0x21,0x3E,0x20,0x70,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x21,0x21,0x21,0x21,0x21,0x1F,0x01,0x03,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x77,0x19,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x22,0x20,0x1C,0x02,0x22,0x3C,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x08,0x08,0x3E,0x08,0x08,0x08,0x08,0x08,0x06,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x63,0x21,0x21,0x21,0x21,0x23,0x1D,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x73,0x21,0x12,0x12,0x14,0x08,0x08,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x10,0x7B,0x3A,0x3A,0x3A,0x14,0x14,0x14,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x37,0x12,0x0C,0x0C,0x0C,0x12,0x3B,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x73,0x21,0x12,0x12,0x14,0x0C,0x08,0x08,0x70,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x22,0x04,0x08,0x08,0x11,0x3F,0x00,0x00,0x00,
0x06,0x04,0x04,0x04,0x04,0x04,0x08,0x04,0x04,0x04,0x04,0x04,0x04,0x02,0x00,0x00,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,
0x18,0x08,0x08,0x08,0x08,0x08,0x04,0x08,0x08,0x08,0x08,0x08,0x08,0x10,0x00,0x00,
0x24,0x23,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

};

//unsigned char alphabufferForASCII[512] = {0};
#define  AlphaBufferStartAddr	0x02000000
#define  AlphaBufferSize		512

static SB_tstShortSB astShortSB[CONFIG_SHORT_SB_SIZE];
static uint8_t au8UpgLineInfo[CONFIG_LINE_INFO_SIZE];
static DRAW_tstDrawWorkBuf stDrawWorkbuf;
static bool DRAW_bBackLightOn = FALSE;
/* Indicate if System use Framebuffer, FALSE: no Framebuffer, TRUE: has Framebuffer */
static bool DRAW_bFramebufState = FALSE;


//filetype:  0->cpu0  1->texture  2->cpu1  3->product	4->calibration  5->HWConfig
//optype:  0->verify file		1->erase	2->write	3->verify data  4->Upgrade OK
void DrawProgressBar(uint32_t width, uint32_t height, uint32_t filetype, uint32_t optype, uint32_t value)
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstringop-truncation"

	int tmp;
	char Str[40];
	char progress[32];
    int32_t res;
	uint8_t * pFileName;
    uint32_t strLen;
    const char* space = "                    ";

    if(stDrawWorkbuf.bInited != TRUE)
    {
        return;
    }

    if(((value * 100 / width) % CONFIG_UPG_STEP != 0) && (optype != 4))
    {
        return;
    }
    
	/* no init ahmi core, return */
	if(*((uint32_t *)0x40104030) == 0)
		return;
	
	if(filetype > 8 || optype > 4)
		return;

    res = UPG_i32GetUpgFileName((uint8_t)filetype, &pFileName);
    if(res != UPG_OK)
    {
        return;
    }
    
	memset(Str, 0, sizeof(Str));

    strLen = strlen((char*)pFileName);
    if(strLen >= sizeof(Str))
    {
        return;
    }
    else if(strLen < 16) 
    {
        strcpy(Str, (const char*)pFileName);
        strncpy(&Str[strLen], space, 16 - strLen);
    }
    
      
	switch(optype)
	{
		case 0:
			strncat(Str, "VerifyFile   ", 12); 
		break;
		case 1:
			strncat(Str, "Erase        ", 12); 
		break;
		case 2:
			strncat(Str, "Write        ", 12); 
		break;
		case 3:
			strncat(Str, "VerifyData   ", 12); 
		break;
        case 4:
			strncat(Str, "Upgrade      OK     ", 18); 
		break;
		default:
			
		break;
	}
	

	
	sprintf(progress, "%3d%%", (value * 100 / width));
    if(optype < 4)
    {
        strncat(Str, progress, 5);
    }
	
	DRAW_vDrawString(filetype, 0, LINE_NUM_AUTO, 0xffffff, (const char*)Str, TRUE);
    
    if(FALSE == DRAW_bBackLightOn)
    {
        DRAW_vBackLightOpen();
        DRAW_bBackLightOn = TRUE;
    }
#pragma GCC diagnostic pop	
}


void DrawErrorBackground(uint32_t width, uint32_t height, uint8_t level, const uint8_t* pChar)
{
	int color;

    if(stDrawWorkbuf.bInited != TRUE)
    {
        return;
    }
    
	/* no init ahmi core, return */
	if(*((uint32_t *)0x40104030) == 0)
		return;
	
	/* Adjust the background according to the resolution */
	switch(level)
	{
		case EM_enErrLevelWarning:
			color = ErrorBackground_YELLOW;
		break;
		
		case EM_enErrLevelSerious:
			color = ErrorBackground_BLUE;
		break;
		
		case EM_enErrLevelFatal:
			color = ErrorBackground_RED;
		break;
		
		default:
			return;
		break;
	}

    DRAW_vDrawString(NOT_UPG_FILE, 0, 16, color, (const char*)pChar, TRUE);
    
    if(FALSE == DRAW_bBackLightOn)
    {
        DRAW_vBackLightOpen();
        DRAW_bBackLightOn = TRUE;
    }
	
}

u8 changeBytePort(u8 input)
{
	u8 result = 0, i;

	for(i = 0; i < 8; i++)
	{
		if(input & (1 << (7 - i)))
		{
			result |= (1 << i);
		}
	}

	return result;
}

void add_to_bitarray(uint8_t *bitarr, int32_t num)//num means data to be inset
{
	bitarr[num >> 3] |= (1 << (num & 0x7));
}

void SetString(u32 screenwidth, u32 screenheight, u16 posX, u16 posY, u16 FontWidth, u16 FontHeight, u32 FontStartAddr, u32 FontCode, u8 type)
{
	int i = 0, j = 0, byteNumForLine = 0, currentLine = 0, currentLineByte = 0;
	u8 result = 0, outputnum = 0, alignflag = 0;

	if((screenwidth*screenheight/8) > AlphaBufferSize)
		return;
	
	byteNumForLine = FontWidth / 8;
	if(FontWidth % 8 != 0)
	{
		alignflag = 1;
		byteNumForLine++;
	}

	for(i = 0; i < byteNumForLine*FontHeight; i++)
	{
		currentLine = i / byteNumForLine;
		currentLineByte = i % byteNumForLine;

		if((currentLineByte == byteNumForLine - 1) && (alignflag))
		{
			outputnum = FontWidth % 8;
		}
		else
		{
			outputnum = 8;
		}
		
		if(type)
		{
			result = changeBytePort(*(uint8_t *)( FontStartAddr + FontCode*byteNumForLine*FontHeight + i));
		}
        else
        {
			result = changeBytePort(*(uint8_t *)(0xa0000000 + FontStartAddr + FontCode*byteNumForLine*FontHeight + i));
		}
		
		for(j = 0; j < outputnum; j++)
		{
			if((result & (1 << j)) && ((posY + currentLine) < screenheight))
			{
				add_to_bitarray((uint8_t *)AlphaBufferStartAddr, (posY + currentLine) * screenwidth + posX + 8*currentLineByte + j);
			}
		}
	}
}

void ClearAllString(void)
{
    uint32_t i = 0;
    for(i = 0; i < AlphaBufferSize; i++)
    {
        *((uint8_t *)AlphaBufferStartAddr + i) = 0;
    }
//    memset((char*)alphabufferForASCII, 0, sizeof(alphabufferForASCII));
    
}

void DisplayString(u32 screenwidth, u32 screenheight, u16 LineNo, u8* pStrFontCode, u16 strFontCodeLen)
{
    uint32_t width,height,len,i;
    
    width = screenwidth;
    height = screenheight;
    
    if (LineNo < height/16)
    {
        if (strFontCodeLen > width/8)
        {
            len = width/8;
        }
        else
        {
            len = strFontCodeLen;
        }        
        
        for (i=0; i<len; i++)
        {
            SetString(screenwidth, screenheight, i*8, LineNo*16, 8, 16, (u32)(uint8_t*)ASCII_8X16_array, *(pStrFontCode+i), 1);
        }
    }
}


void DRAW_vBackLightInit(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    HAL_GPIO_StructInit(&GPIO_InitStruct);
    
    GPIO_InitStruct.Pin = SYN_GET_CTRL_BL_PIN;
    HAL_GPIO_Init(SYN_GET_CTRL_BL_PORT, &GPIO_InitStruct);
}


void DRAW_vBackLightOpen(void)
{
    HAL_GPIO_WritePin(SYN_GET_CTRL_BL_PORT, SYN_GET_CTRL_BL_PIN, 1);
}


void DRAW_vBackLightClose(void)
{
    HAL_GPIO_WritePin(SYN_GET_CTRL_BL_PORT, SYN_GET_CTRL_BL_PIN, 0);
}


void InitAHMI(void)
{
	AHMI_InitTypeDef AHMI_InitStruct;
	
	AHMI_StructInit(&AHMI_InitStruct);
	Reset_AHMI();
	
	AHMI_ITConfig(IT_DC_RDOVER, ENABLE);
	AHMI_ITConfig(IT_SB_ENF, ENABLE);
	AHMI_ITConfig(IT_SB_RDOVER, ENABLE);
	AHMI_ITConfig(IT_DRAW_DONE, ENABLE);
	
	AHMI_Init(&AHMI_InitStruct);
	//AHMI_InterruptConfig(ENABLE);
	//GPE_Cmd(ENABLE);
	AHMI_SETCoreCallCount(CORE0,0);
	AHMI_SETCoreCallCount(CORE1,0);
//	AHMI_SetRot(DEGREE180);
//	AHMI_TileBox(0x20, 0x20, 0x20, 0x20);
//	AHMI_SetSBSize(256);
//	AHMI_SetSBAdress(0x20000000);
//	AHMI_SetFBAdress(0x20000000);
//	AHMI_SetFSize(800, 480);
//	AHMI_GETCoreCallCount(CORE0);
    DRAW_vInit();
}


void DRAW_vExe(void)
{
    
    //DCache_Flush(); /* Bootloader no use DCache */

    if(GPE_Cmd(ENABLE))
    {

        while( ((AHMI->STR & 0x1) == 1))
        {
        ;};

        while( ((AHMI->STR & 0x1) == 0))
        {
        ;};
    }
}


void DRAW_vTest(void)
{
    int i, j, k, l;
    while(1)
    {
        for(j = 0; j < 6; j++)
        {
            for(l = 0; l < 5; l++)
            {
                for(i = 0; i <= 800; i+= 20)
                {
                    DrawProgressBar(SYN_GET_DISPLAY_WIDTH, 0, j, l, i);
                    for(k = 20000; k >0; k--);
                }
            }
            
       
        }
    }

}


/**
  * @name       DRAW__vDrawInit
  * @brief      Initialization for Drawing background and first Line
  * @note       
  * @param      startFontX: start Font X coordinate number(unit: 8pixel)
  * @param      strColor: color used to draw string in Line0
  * @param      pStr: string to display on Line0
  * @retval     void
  * @author     
  * @date       2023-06-19
  */
void DRAW__vDrawInit(uint8_t startFontX, uint8_t startFontY, uint32_t strColor, const char* pStr)
{
    
    ClearAllString();
    /* Show Information at LINE 0 */
	DisplayString(stDrawWorkbuf.u16StrTextureWidth, stDrawWorkbuf.u16StrTextureHeight, 0, (u8*)pStr, strlen(pStr));

    /* Step1: Initialize background with force Rendering */
    SB_vInitStructByPureColor_Force(&stDrawWorkbuf.pstShortSB[stDrawWorkbuf.u8ShortSBIndex], 0, 0, SYN_GET_DISPLAY_WIDTH, SYN_GET_DISPLAY_HEIGHT, CONFIG_BACKGROUND_COLOR);
    stDrawWorkbuf.u8ShortSBIndex++;

    /* Step2: create Font Texture */
    SB_vInitStructByAlpha1_Noforce(&stDrawWorkbuf.pstShortSB[stDrawWorkbuf.u8ShortSBIndex],  
                                    startFontX * FONT_WIDTH, 
                                    startFontY * FONT_HEIGHT, 
                                    stDrawWorkbuf.u16StrTextureWidth, 
                                    stDrawWorkbuf.u16StrTextureHeight, 
                                    0x30000000);    /* this address need distict between GC9002 and GC9005 */
    stDrawWorkbuf.u8ShortSBIndex++;

    /* Step3: Draw Font Texture on screen used the specified color */
    SB_vInitStructByAlpha1_End(&stDrawWorkbuf.pstShortSB[stDrawWorkbuf.u8ShortSBIndex],  
                                    startFontX * FONT_WIDTH, 
                                    startFontY * FONT_HEIGHT,
                                    stDrawWorkbuf.u16StrTextureWidth, 
                                    stDrawWorkbuf.u16StrTextureHeight, 
                                    0xFF,
                                    strColor);
    stDrawWorkbuf.u8ShortSBIndex++;

    AHMI_SetSBAdress((uint32_t)stDrawWorkbuf.pstShortSB, 0, stDrawWorkbuf.u8ShortSBIndex * sizeof(SB_tstShortSB) / sizeof(uint32_t));
        
	DRAW_vExe();

    stDrawWorkbuf.u8CurLineNum = startFontY;
    stDrawWorkbuf.u8CurLineNum++;
}

/**
  * @name       DRAW_vInit
  * @brief      Initialization function
  * @note       
  * @param      void
  * @retval     void
  * @author     
  * @date       2023-06-19
  */
void DRAW_vInit(void)
{
    memset(&stDrawWorkbuf, 0, sizeof(DRAW_tstDrawWorkBuf));
    memset(astShortSB, 0, sizeof(astShortSB));
    memset(au8UpgLineInfo, 0, sizeof(au8UpgLineInfo));
    stDrawWorkbuf.u8ShortSBTotalNum = CONFIG_SHORT_SB_SIZE;
    stDrawWorkbuf.u8UpgFileTotalNum = CONFIG_LINE_INFO_SIZE;
    stDrawWorkbuf.pstShortSB = astShortSB;
    stDrawWorkbuf.pu8UpgFileLineInfo = au8UpgLineInfo;
    
    stDrawWorkbuf.u32StrTextureAddr = AlphaBufferStartAddr;
    stDrawWorkbuf.u16StrTextureWidth = CONFIG_STR_TEXTURE_WIDTH;
    stDrawWorkbuf.u16StrTextureHeight = CONFIG_STR_TEXTURE_HEIGHT;

    stDrawWorkbuf.u32FrameBufAddr = CONFIG_FRAME_BUF_ADDR;
    if(DISPLAY_InputColorMode_RGBA8888 == DISPLAY_u32GetInputColorMode())
    {
        stDrawWorkbuf.u8TextureOutputType = SB_enTxtrTypeArgb888;
    }
    else
    {
        stDrawWorkbuf.u8TextureOutputType = CONFIG_TEXTURE_OUTPUT_TYPE;
    }

    stDrawWorkbuf.bInited = TRUE;

    DRAW_vBackLightInit();
    /* Draw specified string at Screen on column/row */
    DRAW__vDrawInit(CONFIG_CUSTOMER_INFO_START_COLUMN, CONFIG_CUSTOMER_INFO_START_ROW, CONFIG_CUSTOMER_INFO_HINT_STRING_COLOR, CONFIG_CUSTOMER_INFO_HINT_STRING);
    
    if(SYN_GET_SYS_IF_BL_ALL_ON)
    {
        DRAW_vBackLightOpen();
        DRAW_bBackLightOn = TRUE;
    }
}

/**
  * @name       DRAW_vDeinit
  * @brief      De-initialization function
  * @note       
  * @param      void
  * @retval     void
  * @author     
  * @date       2023-07-19
  */
void DRAW_vDeinit(void)
{
    stDrawWorkbuf.bInited = FALSE;
    DRAW_vBackLightClose();
}

/**
  * @name       DRAW_vDrawString
  * @brief      This will make the SourceBuffer as the last one, so GPU will end draw
  * @note       
  * @param      upgFileIndex: upgrade File Index, in order to record the line number 
  * @param      startFontX: start Font X coordinate number(unit: 8pixel)
  * @param      startFontY: start Font Y coordinate number(unit: 16pixel)
  * @param      color: specify the font color
  * @param      pStr: string to draw
  * @param      forceErase: erase before drawing
  * @retval     void
  * @author     
  * @date       2023-06-19
  */
void DRAW_vDrawString(uint8_t upgFileIndex, uint8_t startFontX, uint8_t startFontY, uint32_t color, const char* pStr, bool forceErase)
{
    int32_t res;
    uint8_t strLen;
    uint8_t lineNum;
    bool hasFramebuffer;

    strLen = strlen(pStr);
    if(0 == strLen || (FALSE == stDrawWorkbuf.bInited))
    {
        return;
    }

    if(LINE_NUM_AUTO == startFontY && NOT_UPG_FILE != upgFileIndex)
    {
        if(upgFileIndex < CONFIG_LINE_INFO_SIZE)
        {
            /* usually Upgrade File Info drawing start from Line 1 */
            if(0 == stDrawWorkbuf.pu8UpgFileLineInfo[upgFileIndex])
            {
                stDrawWorkbuf.pu8UpgFileLineInfo[upgFileIndex] = stDrawWorkbuf.u8CurLineNum++;
            }
            /* Get Line number from buffer */
            lineNum = stDrawWorkbuf.pu8UpgFileLineInfo[upgFileIndex];
        }
        else
        {
            /* record err */
        
            return;
        }
    }
    else
    {
        lineNum = startFontY;
    }

    ClearAllString();
    DisplayString(stDrawWorkbuf.u16StrTextureWidth, stDrawWorkbuf.u16StrTextureHeight, 0, (uint8_t*)pStr, strLen);
    
    stDrawWorkbuf.u8ShortSBIndex = 0;
    hasFramebuffer = DRAW_bGetFramebufState();
    
    /* Only system has Framebuf need to Re-Draw */
    if(hasFramebuffer)
    {
        /* Step1: Re-Draw FrameBuffer */
        SB_vInitStructByLastFrameBuffer_Force(&stDrawWorkbuf.pstShortSB[stDrawWorkbuf.u8ShortSBIndex], stDrawWorkbuf.u32FrameBufAddr , stDrawWorkbuf.u8TextureOutputType);
    }
    else
    {
        /* Step1: Initialize background with force Rendering */
        SB_vInitStructByPureColor_Force(&stDrawWorkbuf.pstShortSB[stDrawWorkbuf.u8ShortSBIndex], 0, 0, SYN_GET_DISPLAY_WIDTH, SYN_GET_DISPLAY_HEIGHT, CONFIG_BACKGROUND_COLOR);
    }
    stDrawWorkbuf.u8ShortSBIndex++;
    
    /* Step2: erase the Drawing area by background color */
    if(forceErase && hasFramebuffer) /* only has Framebuf need to erase */
    {
        SB_vInitStructByPureColor_Noforce(&stDrawWorkbuf.pstShortSB[stDrawWorkbuf.u8ShortSBIndex],  
                                    startFontX * FONT_WIDTH, 
                                    lineNum * FONT_HEIGHT, 
                                    strLen * FONT_WIDTH, 
                                    FONT_HEIGHT, 
                                    CONFIG_BACKGROUND_COLOR);
        stDrawWorkbuf.u8ShortSBIndex++;
    }

    /* Step3: create Font Texture */
    SB_vInitStructByAlpha1_Noforce(&stDrawWorkbuf.pstShortSB[stDrawWorkbuf.u8ShortSBIndex],  
                                    startFontX * FONT_WIDTH, 
                                    lineNum * FONT_HEIGHT, 
                                    stDrawWorkbuf.u16StrTextureWidth, 
                                    stDrawWorkbuf.u16StrTextureHeight, 
                                    0x30000000);    /* this address need distict between GC9002 and GC9005 */
    stDrawWorkbuf.u8ShortSBIndex++;

    /* Step4: Draw Font Texture on screen used the specified color */
    SB_vInitStructByAlpha1_End(&stDrawWorkbuf.pstShortSB[stDrawWorkbuf.u8ShortSBIndex],  
                                    startFontX * FONT_WIDTH, 
                                    lineNum * FONT_HEIGHT, 
                                    stDrawWorkbuf.u16StrTextureWidth, 
                                    stDrawWorkbuf.u16StrTextureHeight, 
                                    0xFF,
                                    color);
    stDrawWorkbuf.u8ShortSBIndex++;

    AHMI_SetSBAdress((uint32_t)stDrawWorkbuf.pstShortSB, 0, stDrawWorkbuf.u8ShortSBIndex * sizeof(SB_tstShortSB) / sizeof(uint32_t));
        
    if(hasFramebuffer)
    {
        AHMI_SetPara(startFontX * FONT_WIDTH, 0, strLen * FONT_WIDTH, (lineNum + 1) * FONT_HEIGHT);
    }
    
	DRAW_vExe();
    
}


/**
  * @name       DRAW_vSetFramebufState
  * @brief      Set Framebuffer state
  * @note       
  * @param      bool, TRUE: has framebuf, FALSE: no framebuffer
  * @retval     void
  * @author     
  * @date       2023-10-24
  */
void DRAW_vSetFramebufState(bool framebufState)
{
    DRAW_bFramebufState = framebufState;
}


/**
  * @name       DRAW_vSetFramebufState
  * @brief      Set Framebuffer state
  * @note       
  * @param      void
  * @retval     bool, TRUE: has framebuf, FALSE: no framebuffer
  * @author     
  * @date       2023-10-24
  */
bool DRAW_bGetFramebufState(void)
{
    return DRAW_bFramebufState;
}

